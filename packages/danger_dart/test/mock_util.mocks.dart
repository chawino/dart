// Mocks generated by Mockito 5.1.0 from annotations
// in danger_dart/test/mock_util.dart.
// Do not manually edit this file.

import 'dart:async' as _i3;
import 'dart:convert' as _i5;
import 'dart:io' as _i4;

import 'package:args/args.dart' as _i6;
import 'package:danger_core/src/models/danger_results.dart' as _i8;
import 'package:danger_dart/danger_util.dart' as _i2;
import 'package:mockito/mockito.dart' as _i1;
import 'package:process_run/shell.dart' as _i7;

// ignore_for_file: type=lint
// ignore_for_file: avoid_redundant_argument_values
// ignore_for_file: avoid_setters_without_getters
// ignore_for_file: comment_references
// ignore_for_file: implementation_imports
// ignore_for_file: invalid_use_of_visible_for_testing_member
// ignore_for_file: prefer_const_constructors
// ignore_for_file: unnecessary_parenthesis
// ignore_for_file: camel_case_types

class _FakeDangerJSMetadata_0 extends _i1.Fake implements _i2.DangerJSMetadata {
}

class _FakeStreamSubscription_1<T> extends _i1.Fake
    implements _i3.StreamSubscription<T> {}

class _FakeIOSink_2 extends _i1.Fake implements _i4.IOSink {}

class _FakeEncoding_3 extends _i1.Fake implements _i5.Encoding {}

/// A class which mocks [DangerUtil].
///
/// See the documentation for Mockito's code generation for more information.
class MockDangerUtil extends _i1.Mock implements _i2.DangerUtil {
  MockDangerUtil() {
    _i1.throwOnMissingStub(this);
  }

  @override
  String getScriptFilePath() =>
      (super.noSuchMethod(Invocation.method(#getScriptFilePath, []),
          returnValue: '') as String);
  @override
  String getDangerFile(_i6.ArgResults? args) =>
      (super.noSuchMethod(Invocation.method(#getDangerFile, [args]),
          returnValue: '') as String);
  @override
  _i3.Future<List<_i4.ProcessResult>> execShellCommand(String? command,
          {_i7.Shell? shell, bool? isVerbose}) =>
      (super.noSuchMethod(
              Invocation.method(#execShellCommand, [command],
                  {#shell: shell, #isVerbose: isVerbose}),
              returnValue:
                  Future<List<_i4.ProcessResult>>.value(<_i4.ProcessResult>[]))
          as _i3.Future<List<_i4.ProcessResult>>);
  @override
  _i3.Future<_i2.DangerJSMetadata> getDangerJSMetaData(_i6.ArgResults? args,
          {_i7.Shell? shell}) =>
      (super.noSuchMethod(
              Invocation.method(#getDangerJSMetaData, [args], {#shell: shell}),
              returnValue:
                  Future<_i2.DangerJSMetadata>.value(_FakeDangerJSMetadata_0()))
          as _i3.Future<_i2.DangerJSMetadata>);
  @override
  _i3.Future<void> spawnFile(
          _i4.File? dangerFile, dynamic message, bool? isDebug) =>
      (super.noSuchMethod(
          Invocation.method(#spawnFile, [dangerFile, message, isDebug]),
          returnValue: Future<void>.value(),
          returnValueForMissingStub: Future<void>.value()) as _i3.Future<void>);
  @override
  void sortDangerResult(_i8.DangerResults? results) =>
      super.noSuchMethod(Invocation.method(#sortDangerResult, [results]),
          returnValueForMissingStub: null);
}

/// A class which mocks [Stdin].
///
/// See the documentation for Mockito's code generation for more information.
class MockStdin extends _i1.Mock implements _i4.Stdin {
  MockStdin() {
    _i1.throwOnMissingStub(this);
  }

  @override
  bool get echoMode =>
      (super.noSuchMethod(Invocation.getter(#echoMode), returnValue: false)
          as bool);
  @override
  set echoMode(bool? echoMode) =>
      super.noSuchMethod(Invocation.setter(#echoMode, echoMode),
          returnValueForMissingStub: null);
  @override
  bool get lineMode =>
      (super.noSuchMethod(Invocation.getter(#lineMode), returnValue: false)
          as bool);
  @override
  set lineMode(bool? lineMode) =>
      super.noSuchMethod(Invocation.setter(#lineMode, lineMode),
          returnValueForMissingStub: null);
  @override
  bool get supportsAnsiEscapes =>
      (super.noSuchMethod(Invocation.getter(#supportsAnsiEscapes),
          returnValue: false) as bool);
  @override
  bool get hasTerminal =>
      (super.noSuchMethod(Invocation.getter(#hasTerminal), returnValue: false)
          as bool);
  @override
  bool get isBroadcast =>
      (super.noSuchMethod(Invocation.getter(#isBroadcast), returnValue: false)
          as bool);
  @override
  _i3.Future<int> get length => (super.noSuchMethod(Invocation.getter(#length),
      returnValue: Future<int>.value(0)) as _i3.Future<int>);
  @override
  _i3.Future<bool> get isEmpty =>
      (super.noSuchMethod(Invocation.getter(#isEmpty),
          returnValue: Future<bool>.value(false)) as _i3.Future<bool>);
  @override
  _i3.Future<List<int>> get first => (super.noSuchMethod(
      Invocation.getter(#first),
      returnValue: Future<List<int>>.value(<int>[])) as _i3.Future<List<int>>);
  @override
  _i3.Future<List<int>> get last => (super.noSuchMethod(
      Invocation.getter(#last),
      returnValue: Future<List<int>>.value(<int>[])) as _i3.Future<List<int>>);
  @override
  _i3.Future<List<int>> get single => (super.noSuchMethod(
      Invocation.getter(#single),
      returnValue: Future<List<int>>.value(<int>[])) as _i3.Future<List<int>>);
  @override
  String? readLineSync(
          {_i5.Encoding? encoding = const _i4.SystemEncoding(),
          bool? retainNewlines = false}) =>
      (super.noSuchMethod(Invocation.method(#readLineSync, [],
          {#encoding: encoding, #retainNewlines: retainNewlines})) as String?);
  @override
  int readByteSync() =>
      (super.noSuchMethod(Invocation.method(#readByteSync, []), returnValue: 0)
          as int);
  @override
  _i3.StreamSubscription<List<int>> listen(void Function(List<int>)? onData,
          {Function? onError, void Function()? onDone, bool? cancelOnError}) =>
      (super.noSuchMethod(
              Invocation.method(#listen, [
                onData
              ], {
                #onError: onError,
                #onDone: onDone,
                #cancelOnError: cancelOnError
              }),
              returnValue: _FakeStreamSubscription_1<List<int>>())
          as _i3.StreamSubscription<List<int>>);
  @override
  _i3.Stream<List<int>> asBroadcastStream(
          {void Function(_i3.StreamSubscription<List<int>>)? onListen,
          void Function(_i3.StreamSubscription<List<int>>)? onCancel}) =>
      (super.noSuchMethod(
          Invocation.method(#asBroadcastStream, [],
              {#onListen: onListen, #onCancel: onCancel}),
          returnValue: Stream<List<int>>.empty()) as _i3.Stream<List<int>>);
  @override
  _i3.Stream<List<int>> where(bool Function(List<int>)? test) =>
      (super.noSuchMethod(Invocation.method(#where, [test]),
          returnValue: Stream<List<int>>.empty()) as _i3.Stream<List<int>>);
  @override
  _i3.Stream<S> map<S>(S Function(List<int>)? convert) =>
      (super.noSuchMethod(Invocation.method(#map, [convert]),
          returnValue: Stream<S>.empty()) as _i3.Stream<S>);
  @override
  _i3.Stream<E> asyncMap<E>(_i3.FutureOr<E>? Function(List<int>)? convert) =>
      (super.noSuchMethod(Invocation.method(#asyncMap, [convert]),
          returnValue: Stream<E>.empty()) as _i3.Stream<E>);
  @override
  _i3.Stream<E> asyncExpand<E>(_i3.Stream<E>? Function(List<int>)? convert) =>
      (super.noSuchMethod(Invocation.method(#asyncExpand, [convert]),
          returnValue: Stream<E>.empty()) as _i3.Stream<E>);
  @override
  _i3.Stream<List<int>> handleError(Function? onError,
          {bool Function(dynamic)? test}) =>
      (super.noSuchMethod(
          Invocation.method(#handleError, [onError], {#test: test}),
          returnValue: Stream<List<int>>.empty()) as _i3.Stream<List<int>>);
  @override
  _i3.Stream<S> expand<S>(Iterable<S> Function(List<int>)? convert) =>
      (super.noSuchMethod(Invocation.method(#expand, [convert]),
          returnValue: Stream<S>.empty()) as _i3.Stream<S>);
  @override
  _i3.Future<dynamic> pipe(_i3.StreamConsumer<List<int>>? streamConsumer) =>
      (super.noSuchMethod(Invocation.method(#pipe, [streamConsumer]),
          returnValue: Future<dynamic>.value()) as _i3.Future<dynamic>);
  @override
  _i3.Stream<S> transform<S>(
          _i3.StreamTransformer<List<int>, S>? streamTransformer) =>
      (super.noSuchMethod(Invocation.method(#transform, [streamTransformer]),
          returnValue: Stream<S>.empty()) as _i3.Stream<S>);
  @override
  _i3.Future<List<int>> reduce(
          List<int> Function(List<int>, List<int>)? combine) =>
      (super.noSuchMethod(Invocation.method(#reduce, [combine]),
              returnValue: Future<List<int>>.value(<int>[]))
          as _i3.Future<List<int>>);
  @override
  _i3.Future<S> fold<S>(S? initialValue, S Function(S, List<int>)? combine) =>
      (super.noSuchMethod(Invocation.method(#fold, [initialValue, combine]),
          returnValue: Future<S>.value(null)) as _i3.Future<S>);
  @override
  _i3.Future<String> join([String? separator = r'']) =>
      (super.noSuchMethod(Invocation.method(#join, [separator]),
          returnValue: Future<String>.value('')) as _i3.Future<String>);
  @override
  _i3.Future<bool> contains(Object? needle) =>
      (super.noSuchMethod(Invocation.method(#contains, [needle]),
          returnValue: Future<bool>.value(false)) as _i3.Future<bool>);
  @override
  _i3.Future<dynamic> forEach(void Function(List<int>)? action) =>
      (super.noSuchMethod(Invocation.method(#forEach, [action]),
          returnValue: Future<dynamic>.value()) as _i3.Future<dynamic>);
  @override
  _i3.Future<bool> every(bool Function(List<int>)? test) =>
      (super.noSuchMethod(Invocation.method(#every, [test]),
          returnValue: Future<bool>.value(false)) as _i3.Future<bool>);
  @override
  _i3.Future<bool> any(bool Function(List<int>)? test) =>
      (super.noSuchMethod(Invocation.method(#any, [test]),
          returnValue: Future<bool>.value(false)) as _i3.Future<bool>);
  @override
  _i3.Stream<R> cast<R>() => (super.noSuchMethod(Invocation.method(#cast, []),
      returnValue: Stream<R>.empty()) as _i3.Stream<R>);
  @override
  _i3.Future<List<List<int>>> toList() =>
      (super.noSuchMethod(Invocation.method(#toList, []),
              returnValue: Future<List<List<int>>>.value(<List<int>>[]))
          as _i3.Future<List<List<int>>>);
  @override
  _i3.Future<Set<List<int>>> toSet() =>
      (super.noSuchMethod(Invocation.method(#toSet, []),
              returnValue: Future<Set<List<int>>>.value(<List<int>>{}))
          as _i3.Future<Set<List<int>>>);
  @override
  _i3.Future<E> drain<E>([E? futureValue]) =>
      (super.noSuchMethod(Invocation.method(#drain, [futureValue]),
          returnValue: Future<E>.value(null)) as _i3.Future<E>);
  @override
  _i3.Stream<List<int>> take(int? count) =>
      (super.noSuchMethod(Invocation.method(#take, [count]),
          returnValue: Stream<List<int>>.empty()) as _i3.Stream<List<int>>);
  @override
  _i3.Stream<List<int>> takeWhile(bool Function(List<int>)? test) =>
      (super.noSuchMethod(Invocation.method(#takeWhile, [test]),
          returnValue: Stream<List<int>>.empty()) as _i3.Stream<List<int>>);
  @override
  _i3.Stream<List<int>> skip(int? count) =>
      (super.noSuchMethod(Invocation.method(#skip, [count]),
          returnValue: Stream<List<int>>.empty()) as _i3.Stream<List<int>>);
  @override
  _i3.Stream<List<int>> skipWhile(bool Function(List<int>)? test) =>
      (super.noSuchMethod(Invocation.method(#skipWhile, [test]),
          returnValue: Stream<List<int>>.empty()) as _i3.Stream<List<int>>);
  @override
  _i3.Stream<List<int>> distinct(
          [bool Function(List<int>, List<int>)? equals]) =>
      (super.noSuchMethod(Invocation.method(#distinct, [equals]),
          returnValue: Stream<List<int>>.empty()) as _i3.Stream<List<int>>);
  @override
  _i3.Future<List<int>> firstWhere(bool Function(List<int>)? test,
          {List<int> Function()? orElse}) =>
      (super.noSuchMethod(
              Invocation.method(#firstWhere, [test], {#orElse: orElse}),
              returnValue: Future<List<int>>.value(<int>[]))
          as _i3.Future<List<int>>);
  @override
  _i3.Future<List<int>> lastWhere(bool Function(List<int>)? test,
          {List<int> Function()? orElse}) =>
      (super.noSuchMethod(
              Invocation.method(#lastWhere, [test], {#orElse: orElse}),
              returnValue: Future<List<int>>.value(<int>[]))
          as _i3.Future<List<int>>);
  @override
  _i3.Future<List<int>> singleWhere(bool Function(List<int>)? test,
          {List<int> Function()? orElse}) =>
      (super.noSuchMethod(
              Invocation.method(#singleWhere, [test], {#orElse: orElse}),
              returnValue: Future<List<int>>.value(<int>[]))
          as _i3.Future<List<int>>);
  @override
  _i3.Future<List<int>> elementAt(int? index) => (super.noSuchMethod(
      Invocation.method(#elementAt, [index]),
      returnValue: Future<List<int>>.value(<int>[])) as _i3.Future<List<int>>);
  @override
  _i3.Stream<List<int>> timeout(Duration? timeLimit,
          {void Function(_i3.EventSink<List<int>>)? onTimeout}) =>
      (super.noSuchMethod(
          Invocation.method(#timeout, [timeLimit], {#onTimeout: onTimeout}),
          returnValue: Stream<List<int>>.empty()) as _i3.Stream<List<int>>);
}

/// A class which mocks [Stdout].
///
/// See the documentation for Mockito's code generation for more information.
class MockStdout extends _i1.Mock implements _i4.Stdout {
  MockStdout() {
    _i1.throwOnMissingStub(this);
  }

  @override
  bool get hasTerminal =>
      (super.noSuchMethod(Invocation.getter(#hasTerminal), returnValue: false)
          as bool);
  @override
  int get terminalColumns =>
      (super.noSuchMethod(Invocation.getter(#terminalColumns), returnValue: 0)
          as int);
  @override
  int get terminalLines =>
      (super.noSuchMethod(Invocation.getter(#terminalLines), returnValue: 0)
          as int);
  @override
  bool get supportsAnsiEscapes =>
      (super.noSuchMethod(Invocation.getter(#supportsAnsiEscapes),
          returnValue: false) as bool);
  @override
  _i4.IOSink get nonBlocking =>
      (super.noSuchMethod(Invocation.getter(#nonBlocking),
          returnValue: _FakeIOSink_2()) as _i4.IOSink);
  @override
  _i5.Encoding get encoding => (super.noSuchMethod(Invocation.getter(#encoding),
      returnValue: _FakeEncoding_3()) as _i5.Encoding);
  @override
  set encoding(_i5.Encoding? encoding) =>
      super.noSuchMethod(Invocation.setter(#encoding, encoding),
          returnValueForMissingStub: null);
  @override
  _i3.Future<dynamic> get done => (super.noSuchMethod(Invocation.getter(#done),
      returnValue: Future<dynamic>.value()) as _i3.Future<dynamic>);
  @override
  void write(Object? object) =>
      super.noSuchMethod(Invocation.method(#write, [object]),
          returnValueForMissingStub: null);
  @override
  void writeln([Object? object = r'']) =>
      super.noSuchMethod(Invocation.method(#writeln, [object]),
          returnValueForMissingStub: null);
  @override
  void writeAll(Iterable<dynamic>? objects, [String? sep = r'']) =>
      super.noSuchMethod(Invocation.method(#writeAll, [objects, sep]),
          returnValueForMissingStub: null);
  @override
  void add(List<int>? data) =>
      super.noSuchMethod(Invocation.method(#add, [data]),
          returnValueForMissingStub: null);
  @override
  void addError(Object? error, [StackTrace? stackTrace]) =>
      super.noSuchMethod(Invocation.method(#addError, [error, stackTrace]),
          returnValueForMissingStub: null);
  @override
  void writeCharCode(int? charCode) =>
      super.noSuchMethod(Invocation.method(#writeCharCode, [charCode]),
          returnValueForMissingStub: null);
  @override
  _i3.Future<dynamic> addStream(_i3.Stream<List<int>>? stream) =>
      (super.noSuchMethod(Invocation.method(#addStream, [stream]),
          returnValue: Future<dynamic>.value()) as _i3.Future<dynamic>);
  @override
  _i3.Future<dynamic> flush() =>
      (super.noSuchMethod(Invocation.method(#flush, []),
          returnValue: Future<dynamic>.value()) as _i3.Future<dynamic>);
  @override
  _i3.Future<dynamic> close() =>
      (super.noSuchMethod(Invocation.method(#close, []),
          returnValue: Future<dynamic>.value()) as _i3.Future<dynamic>);
}
